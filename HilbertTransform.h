#pragma once
#include <complex>
#include <fftw3.h>
#include "wrappers.h"

namespace mathtool
{
    // calculate hilbert transform real to real on the whole real line:
    // Hf = 1/pi * P.V. \int f(y)/(x-y) dy
    // the nodes are not uniformly distributed, they are generated by
    // x = tan(theta/2), where theta(k) = -pi + 2*pi/N * k, N is the total number of nodes.
    // the program requires f(+- infity) = 0, input function data is f(x(:)) as a vector.
    // the basic data type is double

    

    struct Hilbert_plan
    {
        // FFT plans
        fftw_plan fft;
        fftw_plan ifft_p;
        fftw_plan ifft_m;
        // for FFT variables setting
        int n;
        vec_d f;
        vec_cd F;  // F(f)
        vec_cd Fp; // Fp(f)
        vec_cd Fm; // Fm(f)
        vec_cd Mp;
        vec_cd Mm;
        cd &v; // v = Mp.coeffRef(0)
        inline Hilbert_plan(const int &n)
            : n(n),
              f(Eigen::VectorXd::Zero(n)),
              F(Eigen::VectorXcd::Zero(n)),
              Fp(Eigen::VectorXcd::Zero(n)),
              Fm(Eigen::VectorXcd::Zero(n)),
              Mp(Eigen::VectorXcd::Zero(n)),
              Mm(Eigen::VectorXcd::Zero(n)),
              v(Mp.coeffRef(0))
        {
            fft = fftw_plan_dft_r2c_1d(n, f.data(), reinterpret_cast<fftw_complex *>(F.data()), FFTW_MEASURE);
            ifft_p = fftw_plan_dft_1d(n, reinterpret_cast<fftw_complex *>(Fp.data()), reinterpret_cast<fftw_complex *>(Mp.data()), 1, FFTW_MEASURE);
            ifft_m = fftw_plan_dft_1d(n, reinterpret_cast<fftw_complex *>(Fm.data()), reinterpret_cast<fftw_complex *>(Mm.data()), 1, FFTW_MEASURE);
        }
    };

    inline Hilbert_plan Hilbert_initiate(const int &n)
    {
        return Hilbert_plan(n);
    }

    inline void Hilbert_destory(Hilbert_plan &plan)
    {
        fftw_destroy_plan(plan.fft);
        fftw_destroy_plan(plan.ifft_p);
        fftw_destroy_plan(plan.ifft_m);
    }

    inline void Hilbert_r2r_inplace(const vec_d &in, vec_d &out, Hilbert_plan &plan)
    {
        plan.Fp.setZero();
        plan.Fm.setZero();
        fftw_execute_dft_r2c(plan.fft, (double *)in.data(), reinterpret_cast<fftw_complex *>(plan.F.data()));
        plan.Fp.head(plan.n / 2) = plan.F.head(plan.n / 2);
        plan.Fm.tail(plan.n / 2) = plan.F.segment(1, plan.n / 2).reverse().conjugate();
        fftw_execute(plan.ifft_p);
        fftw_execute(plan.ifft_m);
        plan.Mp /= plan.n;
        plan.Mm /= plan.n;
        out = (-1.0i * (plan.Mp - plan.Mm - 2.0 * plan.v)).real();
    }

    inline vec_d Hilbert_r2r(const vec_d &in, Hilbert_plan &plan)
    {
        vec_d out = vec_d::Zero(plan.n);
        Hilbert_r2r_inplace(in, out, plan);
        return out;
    }

}; // namespace mathtool
