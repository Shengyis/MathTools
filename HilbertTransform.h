#pragma once
#include "types.h"
#include <eigen3/unsupported/Eigen/FFT>

namespace mathtool
{
    // calculate hilbert transform real to real on the whole real line:
    // Hf = 1/pi * P.V. \int f(y)/(x-y) dy
    // the nodes are not uniformly distributed, they are generated by
    // x = tan(theta/2), where theta(k) = -pi + 2*pi/N * k, N is the total number of nodes.
    // the program requires f(+- infity) = 0, input function data is f(x(:)) as a vector.
    // support multiprecision number
    
    template <typename T>
    struct FFT_PLAN
    {
        static Eigen::FFT<typename Type<T>::real_scalar> fft;
    };

    template <typename T>
    Eigen::FFT<typename Type<T>::real_scalar> FFT_PLAN<T>::fft;

    template <typename T1, typename T2>
    inline void hilbert_r2r_inplace(const Eigen::MatrixBase<T1> &in, Eigen::MatrixBase<T2> &out)
    {
        static_assert(std::is_same<typename Type<T1>::real_scalar, typename Type<T2>::real_scalar>::value == 1, "in and out vec have different base data type.");
        typedef FFT_PLAN<typename Type<T1>::real_scalar> FFTP;
        static typename Type<T1>::vec_c Fp, Fm, F, Mp, Mm;
        
        int n = in.size();
        assert(n % 2 == 0);
        FFTP::fft.fwd(F, in);
        Fp.resize(n);
        Fm.resize(n);
        Fp.head(n / 2) = F.head(n / 2);
        Fp.tail(n / 2).setZero();
        Fm.tail(n / 2) = F.tail(n / 2);
        Fm.head(n / 2).setZero();
        FFTP::fft.inv(Mp, Fp);
        FFTP::fft.inv(Mm, Fm);
        out = (-1.0i * (Mp - Mm - 2.0 * Mp(0))).real();
    }

    template <typename T>
    inline typename Type<T>::vec hilbert_r2r(const Eigen::MatrixBase<T> &in)
    {
        typename Type<T>::vec out(in.size());
        hilbert_r2r_inplace(in, out);
        return out;
    }
};